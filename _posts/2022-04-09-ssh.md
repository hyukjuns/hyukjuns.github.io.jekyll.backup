---
title: SSH
excerpt: SSH에 대해 자세히 알아봅니다.
categories:
    - Infrastructure
tags:
    - Infrastructure
    - SSH
    - Linux
toc: true
# toc_sticky: true
toc_label: "Contents"
---

> 평소에 무의식적으로 사용하기 마련인 SSH 프로토콜에 대해 살펴봅니다.

## SSH(Secure Shell)
![](https://images.velog.io/images/hyukjun/post/b6eb4da1-1d55-4309-a304-b3343a77b159/image.png)*Image from ssh.com*

SSH(Secure Shell)는 원격 호스트 접속에 사용 되는 가장 일반적인 보안 프로토콜 입니다.

기존의 Telnet과 같은 암호화 되지 않는 원격 접속 프로토콜을 대체하기 위해 설계 되었으며, 네트워크 상의 다른 컴퓨터에 안전하게 로그인 하도록 강력한 인증 방법을 제공해주고, 원격 명령 실행 및 파일 복사와 같은 데이터 통신을 안전하게 수행하도록 해주는 보안 프로토콜 입니다.

원격 호스트에 안전하고 편리하게 접속하게 해주는 SSH를 평소 무의식적으로 사용하고 있지만, 이번 기회에 그 동작원리에 대해 자세히 살펴보고자 합니다.

>  또 다른 원격 호스트 접속용 프로토콜인 Telnet은 암호화를 제공하지 않기 때문에 원격으로 전송되는 데이터를 손쉽게 탈취당할 수 있어 보안상 매우 위험합니다.

![](https://images.velog.io/images/hyukjun/post/c65c8cbf-ae3f-4ded-8b92-086e1287f873/image.png)*Image from ssh.com*

## 키기반 인증 기본 동작 원리
SSH는 대칭키와 비대칭키 방식을 조합해 서버-클라이언트 간 상호 인증을 하고, 통신을 위한 보안 채널을 형성합니다. 서버-클라이언트간 인증은 비대칭키 방식으로 수행되고, 대칭키(*세션키)를 사용해 모든 데이터 통신을 암호화 합니다. (대칭키(*세션키)를 서로 교환할때는 비대칭키 방식을 사용하지만 인증을 위한 비대칭키와는 다른 비대칭키 입니다.) 

**대칭키 (symmetric-key algorithm)**
통신하는 양 쪽 모두 동일한 하나의 키(key)를 사용해 데이터를 암/복호화 하는 방식을 말합니다.
데이터 송수신시 비대칭키에 비하여 암/복호화 계산 속도가 빨라 서버에 무리가 가진 않지만 대칭키를 사용하기 위해 서버-클라이언트가 대칭키를 주고받는 과정에서 대칭키를 누군가에게 탈취 당하게 되면, 이후 데이터 송수신 시 전송되는 데이터는 키를 가지고 있는 누구나 열어볼 수 있어 매우 위험합니다.

>*세션키 (Session Key)
SSH 채널 연결시 대칭키를 세션키로 부릅니다. 이는 SSH 연결(SSH Connection)을 개별 세션으로 생각하면 이해하기 수월합니다.

**비대칭키 (공개키 암호 방식, public-key cryptography)**
키 페어(Key Pair)를 이루는 공개키(public key)와 비밀키(private key)를 사용해 데이터를 암/복호화 하는 방식을 말합니다. (*비밀키를 개인키로 부르기도 합니다.)
공개키와 비밀키는 서로 쌍을 이루게 됩니다. 공개키로 데이터를 암호화 했다면, 쌍을 이루는 비밀키로 복호화 할 수 있고, 비밀키로 데이터를 암호화 했다면, 이 또한 쌍을 이루는 공개키로 데이터를 복호화 할 수 있습니다.
>- 공개키 암호화 → 비밀키 복호화
- 비밀키 암호화 → 공개키 복호화

다만, 이러한 암/복호화 과정은 계산속도가 대칭키에 대비하여 느리고, 데이터 송수신시 매번 이루어 지게 되면 서버에 부하가 생기기 때문에 실제 데이터 통신에는 대칭키를 비대칭키 방식으로 상호 교환하고 교환된 대칭키를 통해 데이터를 암호화 하여 통신하게 됩니다.


## 키기반 인증 과정
> 클라이언트가 접속 하려는 서버는 SSH 데몬이 실행되고 있고, 원격 호스트 역할을 하는 서버에는 이미 클라이언트가 사용하는 비밀키의 쌍을 이루는 공개키가 저장되어 있는 상태로 가정합니다.

![](https://images.velog.io/images/hyukjun/post/8d6fbad0-0fe2-4930-9f9f-dcadd3532df3/image.png)*Image from ssh.com*

### 0. 연결 요청 및 서버에서 클라이언트로 공개키 전달

클라이언트가 서버에 처음으로 연결(접속) 요청을 하면 서버의 공개키를 받을 건지 묻는 메세지가 나옵니다. 

이때 ‘YES’를 입력하게 되면 서버는 클라이언트로 공개키를 보내고, 전달된 공개키는 클라이언트 사용자의known_hosts 파일에 저장됩니다.

이후 똑같은 서버에 접속 요청을 할때는 서버가 제공하려는 공개키가 known_hosts 파일에 이미 있다면, 다시 전송할 필요가 없기때문에 처음과 달리 공개키 전달에 대한 메세지가 표시되지 않습니다.

### 1. 서버 인증

우선 접속 하려는 원격 호스트가 올바른 서버인지(내가 접속 하려는 서버 인지) 확인을 해야합니다.

이 과정을 자세히 살펴보겠습니다.

클라이언트는 난수(random_value)를 생성하고 해당 난수의 해시값(MD5)를 저장해 둡니다.

이어서 클라이언트는 known_hosts 파일 에서 접속 하려는 서버의 공개키를 사용해 난수를 암호화 하여 서버로 전송합니다.

서버는 해당 공개키의 쌍을 이루는 비밀키로 클라이언트에서 받은 난수를 복호화 하여 난수를 확인 하고 해당 해시값(MD5)를 클라이언트로 내려줍니다.

클라이언트는 보관하고 있던 해시값과 서버가 전달해준 해시값을 비교해 서버가 올바른 서버인지 확인하게 됩니다.

### 2. 세션키(대칭키) 생성

서버-클라이언트간 암호화된 통신을 위해 세션키를 생성하고 서로 교환해야 합니다.

세션키는 데이터 송수신시 암/복호화에 따른 부하가 적게 들어 전송 효율이 좋지만, 서버-클라이언트간 세션키를 주고받을때 세션키를 탈취 당하면 모든 통신이 노출될 수 있는 위험에 빠집니다.

따라서, 세션키를 서버-클라이언트 모두 안전하게 가질수 있도록 키교환 알고리즘인 [디피 헬만 키교환 알고리즘(DH, Diffie–Hellman key exchange)](https://ko.wikipedia.org/wiki/%EB%94%94%ED%94%BC-%ED%97%AC%EB%A8%BC_%ED%82%A4_%EA%B5%90%ED%99%98)에 의해 세션키를 생성하고, 서버-클라이언트 간 세션키를 주고받게 됩니다.

DH 알고리즘을 간단히 말하자면 서버-클라이언트간 각각 보유한 공개키, 개인키를 사용하여 서버-클라이언트 모두 세션키를 생성하는데 관여하고, 또 다른 임시 비대칭키를 생성하여 세션키를 암호화하여 서로 전달할 수 있도록 해주는 알고리즘 입니다. (세션키를 암호화할때 사용 되는 임시 비대칭키는 인증에 사용 되는 비대칭키가 아닙니다.)

이후 모든 데이터 통신에는 세션키를 사용하고, 연결이 끊길 경우 해당 세션키는 자동으로 폐기되어, 해당 연결에서 전송된 데이터는 탈취당할 염려가 없어지게 됩니다. 이후 또다른 SSH 연결시 세션키는 다시 개별적으로 생성되게 됩니다.

### 3. 사용자 인증

이제 서버로 접속 요청을 한 클라이언트가 서버에게 인증을 받을 차례 입니다.

클라이언트가 서버에 접속 요청을 하면 서버는 해당 클라이언트가 접속요청을 한 사용자의 공개키 목록 파일인 authorized_keys 파일 을 확인하여 해당 공개키의 비밀키를 클라이언트가 소유하고 있는지 확인합니다.

이 과정을 자세히 살펴보겠습니다.

서버는 난수(random_value)를 생성해 앞서 확인한 공개키로 난수를 암호화 하여 클라이언트로 보냅니다.

클라이언트는 암호화된 난수를 보유하고 있는 비밀키(암호화에 사용된 공개키와 쌍을 이루는)로 복호화 하고, 복호화된 난수와 앞서 교환한 세션키를 결합하여 해시값(MD5)을 생성합니다.

이후, 클라이언트는 해당 해시값을 비밀키로 암호화해 서버로 보냅니다.

서버는 앞서 사용한 공개키를 통해 클라이언트가 보낸 해시값을 복호화 합니다. 그리고 앞서 생성한 난수와 앞서 교환한 세션키를 결합해 해시값(MD5)를 만들어 서로 비교해보고, 일치한다면 클라이언트를 정상적인 클라이언트로 인증 합니다.

### 4. 데이터 통신

위 과정을 모두 마치면 서버-클라이언트 간에 암호화된 채널을 사용한 데이터 통신이 가능해 집니다.

즉, 안전하게 원격 호스트에 접속하여 원격 명령을 수행할 수 있게 되었습니다.

## 마치며
평소 무의식적으로 원격 접속을 위해 사용하던 SSH의 동작 원리를 살펴보면서 단순히 동작원리를 알게된것 뿐만 아니라, 시크릿 관리에 지금보다 좀 더 주의를 기울여야 한다는 생각이 들었습니다. (실제로 비밀번호 인증을 사용하는 서버에서 Brute-force Attack 을 받는 서버를 목격 했던 기억도 납니다.)

또, SSH 인증에 사용 되는 비밀키 혹은 비밀번호 뿐만 아니라 인프라,개발단의 모든 민감한 시크릿(Secret)에 대해 안전하게 관리하고 편리하게 공유할 수 있는 방법을 다양하게 생각해 봐야겠습니다.

우선, Azure의 Key Vault를 적극적으로 사용해 보려고 합니다. 또, 보안 솔루션 중 각광받는 하시코프의 Vault도 좋은 솔루션이지만, 아직 제대로 사용해본 경험이 없다보니, 좀 더 공부해봐야 알 것 같습니다.

### ps. 알아두면 나쁘지 않은 정보

- SSH 비밀번호 인증
    비밀번호를 통한 클라이언트 인증을 할 경우, 서버 인증 후 생성한 세션키를 통해 비밀번호를 암호화 하여 서버로 전송할 수 있지만, 비밀번호는 브루트포스 공격(Brute-force Attack)과 같은 보안 위험에 노출되기 때문에 키기반 인증보다 상대적으로 보안에 취약합니다.

- 비밀키 파일 권한
	비밀키는 기본적으로 600 이하로 파일권한을 세팅 해주셔야 합니다. 즉, 소유자만 파일을 열람할 수 있어야 합니다. 아닐경우 아래와 같은 에러가 발생합니다.
    ![](https://images.velog.io/images/hyukjun/post/b10a5b4c-3d49-4776-829e-4bfe306c788f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-06%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.22.56.png)
  
- 클라우드 에서 만드는 가상머신 (Azure VM)
    클라우드 에서 만드는 가상머신도 키기반 인증은 물론 비밀번호 인증이 가능합니다. 다만, 키기반 인증으로 처음 가상머신을 만들게 되면 자동으로 비밀번호 인증을 비활성화하고, 생성시 사용한 키페어(key-pair)의 공개키를 가상머신 기본 사용자 홈 디렉토리 밑 .ssh/authorized_keys 파일에 세팅해 줍니다. 또, 클라우드에는 생성한 키페어의 공개키만 보관하고, 비밀키는 키페어 생성시 로컬로 다운받아 관리해야 합니다. 물론, 키페어를 새로 생성하지 않고 기존 보유하고 있는 키페어를 사용할 수 도 있습니다.
    (AWS EC2도 같은 방식으로 알고 있습니다.)
    
- known_hosts → (/home/username/.ssh/known_hosts)
    클라이언트 입장에서 접속 하려는 원격 호스트의 공개키가 저장되는 파일 입니다. 클라이언트 사용자의 홈 디렉토리 밑의 .ssh 디렉토리에 위치합니다.
    
- authorized_keys → (/home/username/.ssh/authorized_keys)
    서버 입장에서 클라이언트 인증에 필요한 공개키가 저장되는 파일입니다. 이 역시 해당하는 사용자 홈 디렉토리 밑의 .ssh 디렉토리에 위치합니다. (ssh-copy-id로 공개키 이동시 저장되는 장소이기도 합니다.)
    
- SCP
    원격지에 파일을 복사(전송)할때 SSH 프로토콜을 사용하는 방법입니다.
    
    ```bash
    # 로컬 file을 원격지로 복사
    scp file host:path
    
    # 원격지 파일을 로컬로 복사
    scp host:file path
    ```
    

## Ref.
---
[SSH 키 쌍을 만드는 자세한 단계 - Azure Virtual Machines](https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/create-ssh-keys-detailed#overview-of-ssh-and-keys)

[SSH Handshake Explained | What is SSH Handshake?](https://goteleport.com/blog/ssh-handshake-explained/)

[[서버보안] SSH #1 - SSH 원리](https://limvo.tistory.com/21)

[SSH 암호화 원리 및 AWS SSH 접속 실습](https://medium.com/@labcloud/ssh-%EC%95%94%ED%98%B8%ED%99%94-%EC%9B%90%EB%A6%AC-%EB%B0%8F-aws-ssh-%EC%A0%91%EC%86%8D-%EC%8B%A4%EC%8A%B5-33a08fa76596)

[[Web] SSH 접속 원리 (feat. 대칭키, 비대칭키 암호화)](https://it-eldorado.tistory.com/157)

[SSH protocol is the standard for strong authentication, secure connection, and encrypted file transfers. We developed it.](https://www.ssh.com/academy/ssh/protocol)

[시큐어 셸 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EC%8B%9C%ED%81%90%EC%96%B4_%EC%85%B8)